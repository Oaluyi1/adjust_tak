name: CICD Deployment

on:
  push:
    branches:
      - feature/adjust_tak
jobs:
  lint-code:
    runs-on: ubuntu-latest
  
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3
  
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: 3.8
    
      - name: Install Dependencies
        run: |
          pip install --no-cache-dir -r requirements.txt
          pip install --upgrade pip
          pip install flake8
          pip install black
      
      - name: Debug installed packages
        run: |
          pip list
        

      - name: Lint Code
        run: |
          flake8 .
          black --check . || true
    
      - name: Display Linting Results
        run: flake8 . --show-source --statistics

  test:
    runs-on: ubuntu-latest
    needs: lint-code
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v2

      - name: Set up Python
        uses: actions/setup-python@v2
        with:
          python-version: 3.8

      - name: Install Dependencies
        run: |
          pip install -r requirements.txt
          pip install --upgrade pip

      - name: Run Tests
        run: python -m unittest testing/test_app.py

  analyse-Dockerfile:
    runs-on: ubuntu-latest
    needs: [lint-code,test]

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v2

      - name: Install Hadolint
        run: |
          sudo wget -O /bin/hadolint https://github.com/hadolint/hadolint/releases/latest/download/hadolint-Linux-x86_64
          sudo chmod +x /bin/hadolint

      - name: Run Hadolint
        run: hadolint Dockerfile

  build-Docker-image:
    runs-on: ubuntu-latest
    needs: analyse-Dockerfile
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
  
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.USERNAME }}
          password: ${{ secrets.PASSWORD }}

      - name: Build Docker Image
        uses: docker/build-push-action@v5.1.0
        with:
          context: .
          file: ./Dockerfile
          push: true
          labels: |
            org.opencontainers.image.title=my-app
            org.opencontainers.image.description=Docker image for the app
          tags: 2470/home_task:latest
        id: docker_build    
      
      - name: Run Security Scan
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: 2470/home_task:latest
          format: 'table'
          exit-code: '0'

  start-minikube:
    runs-on: ubuntu-latest
    needs: [build-Docker-image]
    
    steps:
      - name: install kubectl
        run: |
          curl -Lo kubectl https://storage.googleapis.com/kubernetes-release/release/v1.6.0/bin/linux/amd64/kubectl && chmod +x kubectl && sudo mv kubectl /usr/local/bin/

      - name: Install Minikube
        run: |
          curl -LO https://github.com/kubernetes/minikube/releases/tag/v1.32.0
      
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.USERNAME }}
          password: ${{ secrets.PASSWORD }}
  
  install-helm:
    runs-on: ubuntu-latest
    needs: start-minikube
        
    steps:
      - name: Install Helm
        run: |
          curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3
          chmod 700 get_helm.sh
          ./get_helm.sh
    
  helm-deploy:
    runs-on: ubuntu-latest
    needs: install-helm
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3
    
      - name: Start Minikube
        uses: medyagh/setup-minikube@latest
        id: minikube
        with:
          cache: false
          minikube-version: "latest"
          driver: docker
          container-runtime: containerd
          kubernetes-version: v1.27.9
          cni: bridge
          addons: "docker-registry ingress"
          wait: all
            
      - name: Wait for Minikube to be Ready
        run: |
          minikube status
          kubectl describe node minikube
          kubectl wait --for=condition=Ready node/minikube --timeout=5m

      
      # - name: update KUBECONFIG file
      #   run: |
      #     kubectl config set-context minikube --namespace=my-app
      #     kubectl config get-contexts
      #     kubectl config view --minify > kubeconfig-my-app
      #     export KUBECONFIG=$(pwd)/kubeconfig-my-app
      
      - name: Enable Minikube ingress
        run: |
          minikube addons enable ingress
          minikube addons enable dashboard
          # minikube addons enable metrics-server	

      - name: Deploy with Helm to minikube
        run: |
          helm install --debug my-release helm-charts --namespace my-app

          # # Wait for the pod to be ready
          # set -e
          # seconds=0
          # max_seconds=600  # Adjust the maximum waiting time as needed

          # while [ "$seconds" -lt "$max_seconds" ]; do
          #   pod_status=$(kubectl get pods -n my-app -o jsonpath='{.status.phase}')
          #   if [ "$pod_status" == "Failed" ]; then
          #     echo "Pod failed to start. Exiting..."
          #     exit 1
          #   elif [ "$pod_status" == "Running" ]; then
          #     echo "Pod is running!"
          #     exit 0
          #   else
          #     echo "Waiting for the pod to be ready. Elapsed time: $seconds seconds."
          #     sleep 10
          #     seconds=$((seconds+10))
          #   fi
          # done

          # echo "Timeout: Pod did not become ready within the allotted time."
          # exit 1

      
      - name: Try the cluster !
        run: |
          kubectl get pods -n my-app
          kubectl describe pods -n my-app
          kubectl get deployments -n my-app
          kubectl get services -n my-app
      
      - name: Port-Forward Service
        run: |
          kubectl port-forward service/hello 8080:5000 -n my-app &
          sleep 10  # Sleep for some time to allow port-forward to establish
    
      - name: Test App with cURL
        run: |
          set -e  # Exit on any error  
          # Retry up to 3 times with a 5-second delay
          for i in {1..3}; do
            curl -f http://localhost:8080/hello || true  # Silence curl output
            if [ $? -eq 0 ]; then
              echo "App is accessible!"
              exit 0
            fi
            sleep 5
          done
  
          # App not accessible after retries
          echo "App is not accessible after retries"
          exit 2  # Specific exit code for test failure